## Chapter Five —— 函数primer
****

C++相比于C提供了函数的一些新特性：
* 内联函数
* 按引用传递变量
* 默认的参数值
* 函数重载
* 模板函数

#### 内联函数
在函数声明前加上关键字 inline
在函数定义前加上关键字 inline

通常的做法是省略原型，将整个定义（即函数头和所有的函数代码）放在本应提供原型的地方。

> 内联函数不支持递归

> 通常，如果一个函数占用多余一行，不用考虑将其作为内联函数

##### 宏与内联函数
inline工具是C++新增的特性，C语言使用预处理器语句#define来提供宏——内联代码的原始实现。
例如，下面是一个计算平方的宏：
```cpp
#define SQUARE(X) X*X
```
这并不是通过传递参数实现的，而是通过文本替换来实现的——X是“参数”的符号标记。

#### 引用变量
C++新增了一个符合变量——引用变量。引用是已定义的变量的别名。

> 引用的底层实现是指针

> 引用的主要作用是用作函数的形参，通过引用变量作用参数，函数将使用**原始数据，而非其副本**
> 这样，除了指针之外，引用也为函数处理大型结构提供里一种非常方便的途径。

> 引用必须在声明时进行初始化，并且无法改变引用指向，这一点类似于const指针

作为函数参数时的示意图：
![函数引用参数示意图](imgs/cp5_1.png)

> 注：
> 在函数参数中使用引用时应尽可能使用**const**
> * 可以避免无意中修改原始数据
> * 使得函数能够处理const和非const实参，否则只能接受非const实参
> * 使用const引用使得函数能够正确生成并使用临时变量

##### 右值引用
C++11 新增了一种引用——右值引用（rvalue reference），这种引用可以指向右值，使用`&&`声明

> 新增右值引用的主要目的是：
> 让库设计人员能够提供有些操作的更有效实现。

##### 何时使用引用参数
* 程序员需要修改调用函数中的数据对象
* 通过传递引用而不是整个数据对象，可以提高程序的运行速度

**一些指导原则：**
![指导原则](imgs/cp5_2.png)


#### 默认参数
> 默认参数使得我们能够使用不同数目的参数调用同一个函数

> **注意：**
> 只有函数原型指定了默认值，函数定义与没有默认参数时相同

#### 函数重载
> 函数重载使得我们能够使用多个同名的函数

> 函数重载的关键是函数的参数列表——也成为函数的签名(function signature)
> **函数签名：** 
> * 参数数目
> * 参数类型

> **注意：**
> 使用被重载的函数时，需要在函数调用中使用正确的参数类型：
> ```cpp
> void print(double d, int width); // #1
> void print(long l, int width);   // #2
> void print(int i, int width);    // #3
> // 
> unsigned int year = 3210;
> print(year, 6);              //ambiguous call
> ```
> print()调用无法与任何原型匹配，没有匹配的原型并不会自动停止使用其中某个函数，因为C++有类型转换的机制。如果`#1`是print()的唯一原型，则函数调用print(year,6)将把year转换为double类型。但在上面的代码中，有3个将数字作为第一个参数的原型，因此有3种转换year的方式。在这种情况下，C++将拒绝这种函数调用。并将其视为**错误**！

> 编译器在检查函数签名时，把**类型引用**与**类型本身**视为**同一个签名**：
> ```cpp
> double cube(double x);
> double cube(double & x);
> ```
> 上述两个函数声明并不会被视为函数重载，他们的函数签名一致。

> **const**与**非const**变量可作为函数重载的标签区分

#### 何时使用函数重载
**当函数基本上执行相同的任务，但使用不同形式的数据时，采用函数重载。**

#### 名称修饰
C++通过名称修饰来跟踪每一个重载函数。
例如，我们声明如下一个函数：
```cpp
long MyFunctionFoo(int, float);
```
编译器将其转换为内部表示，也许如下面这样：
```cpp
?MyFunctionFoo@@YAXH
```
将参数数目和类型编码进内部表示，即名称修饰。名称修饰时使用的约定随编译器而异。


#### 函数模板

